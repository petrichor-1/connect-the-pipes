Import "secretblocks.htn"
Import "advanced.htn"
Import "./winScreen.htn"
Import "./loadingScreen.htn"
Import "./levelGeneratorBlocks.htn"
Import "./displayTiles.htn"
Import "./lists.htn"
Import "./animation.htn"

Scene game:
	text level_generator(text: ""):
		When game_starts:
			check_if_else(Self.clone_index == 0):
				Game.generated_levels = 0
				Game.generated_levels_list_offset = 0
				create_a_clone_of_this_object
			else:
				destroy
		When object_is_cloned:
			set_background(color: h(Game.primary_color_hue, s: Game.primary_color_saturation, b: Game.primary_color_brightness))
			custom_block create_list(length_length: 2, content_index_length: 4)
			Game.generated_levels = Self.‚Ü©Ô∏èüìäcreated_list
			Game.generated_levels_list_offset = Game.current_level_index
			index_of_level_generation = Game.current_level_index
			repeat_forever:
				check_if_else(length(Game.generated_levels) < 2500):
					custom_block generate_level(width: Game.board_width, height: Game.board_height, seed: index_of_level_generation)
					custom_block append_to(list: Game.generated_levels, new_item: Self.‚Ü©Ô∏ègenerated_board)
					Game.generated_levels = Self.‚Ü©Ô∏èüìäappended_list
					increase(index_of_level_generation, by: 1)
					# show_popup(message: Game.generated_levels)
				else:
					check_once_if(Game.current_level_index > Game.generated_levels_list_offset):
						list = Game.generated_levels
						new_offset = Game.generated_levels_list_offset
						repeat(times: Game.current_level_index - Game.generated_levels_list_offset):
							custom_block remove_item_in(list: list, at_index: 0)
							# show_popup(message: join("Before: ", with: join(list, with: join("
							# 
							# after: ", with: Self.‚Ü©Ô∏èüìäremoved_list))))
							list = Self.‚Ü©Ô∏èüìäremoved_list
							increase(new_offset, by: 1)
						custom_block rebuild(list: list)
						Game.generated_levels = Self.‚Ü©Ô∏èüìärebuilt_list
						Game.generated_levels_list_offset = new_offset

	text tiles(text: ""):
		üì£check_board = "Check board for finished"
		Game.üì£play = "play"
		Game.üì£Success = "Success!"
		When game_starts:
			broadcast_message(named: Game.üì£play)
		When i_get_a_message(Game.üì£play):
			check_if_else(Self.clone_index == 0):
				Game.is_loading = "true"
				# show_popup(message: join("Looking for level with index ", with: Game.current_level_index))
				custom_block wait_for_level_with(index: Game.current_level_index)
				custom_block get_item_in(list: Game.generated_levels, at_index: Game.current_level_index - Game.generated_levels_list_offset)
				Self.board = Self.‚Ü©Ô∏èüìälist_item
				# Self.board = "|||R||RL||UL||RU||UL|||R|RULRUDL|RDL|UDL|||R|RDL|RDL||RL|UDL|||U|||R||RL||UL||UD||RD||RL||RL|RDL||DL:"
				create_clones_of_this_object(times: Game.board_width * Game.board_height)
				Game.is_loading = "false"
				Game.total_taps = 0
				# show_popup(message: Self.board)
			else:
				Original_object.clone_index_offset = Self.clone_index
				destroy
		When object_is_cloned:
			clone_index = Self.clone_index - Original_object.clone_index_offset - 1
			x = clone_index % Game.board_width
			Self.x = x
			y = floor(clone_index / Game.board_width)
			Self.y = y
			Self.tile_size = min(Game.height * 0.6 / Game.board_height, Game.width * 0.6 / Game.board_width)
			origin_position_x = Game.width / 2 - Self.tile_size * Game.board_width / 2 + Self.tile_size / 2
			origin_position_y = Game.height / 2 - Self.tile_size * Game.board_height / 2 + Self.tile_size / 2
			custom_block get_tile_at(x: x, y: y, board: Self.board, width: Game.board_width)
			custom_block set_image_for(tile: Self.‚Ü©Ô∏ètile)
			# set_text(to: Self.‚Ü©Ô∏ètile, color: h(0,s:0,b:0))
			Self.center_x_position = origin_position_x + Self.tile_size * x
			Self.center_y_position = origin_position_y + Self.tile_size * y
			wait(seconds: 0)
			aspect_ratio = Self.height / Self.width
			set_width(Self.tile_size * Self.üì∫width_multiplier, height: aspect_ratio * Self.tile_size * Self.üì∫height_multiplier)
			Self.times_tapped = random(0, to: 3)
			set_color(h(Game.primary_color_hue, s: Game.primary_color_saturation + 60, b: Game.primary_color_brightness + 50))
			Self.displayed_rotation = Self.times_tapped * 90
			repeat_forever:
				set_position(to_x: Self.center_x_position + Self.tile_size * Self.üì∫offset_radius * cos(Self.üì∫offset_angle + Self.displayed_rotation), y: Self.center_y_position + Self.tile_size * Self.üì∫offset_radius * sin(Self.üì∫offset_angle + Self.displayed_rotation))
		When Self.clone_index > 0:
			set_angle(Self.üì∫rotation_offset + Self.displayed_rotation)
		When Self.displayed_rotation != Self.times_tapped * 90:
			custom_block ease_self_displayed_rotation(from: Self.displayed_rotation, to: Self.times_tapped * 90, milliseconds: 100)
		When is_tapped(Screen):
			check_once_if(absolute_value(Game.last_touch_x - Self.center_x_position) < Self.tile_size / 2 and absolute_value(Game.last_touch_y - Self.center_y_position) < Self.tile_size / 2):
				increase(Self.times_tapped, by: 1)
				increase(Game.total_taps, by: 1)
				# Music taps so that the notes don't give away the solution
				increase(Self.music_taps, by: 1)
				play_note((59 + Self.symmetry) + Self.music_taps % Self.symmetry, rhythm: 0)
				broadcast_message(named: üì£check_board)
				wait(seconds: 0)
				check_once_if(Game.board_complete == "true"):
					broadcast_message(named: Game.üì£Success)
		When i_get_a_message(üì£check_board):
			check_if_else(Self.clone_index == 0):
				Game.board_complete = "true"
			else:
				check_once_if(Self.times_tapped % Self.symmetry != 0):
					Game.board_complete = "false"

	text tap_count_display(text: "Taps: 0"):
		When game_starts:
			send_to_back
			set_position(to_x: Game.width / 2, y: Game.height - Self.height / 2 - 8)
			repeat_forever:
				set_text(to: join("Taps: ", with: Game.total_taps), color: h(Game.primary_color_hue, s: Game.primary_color_saturation + 60, b: Game.primary_color_brightness + 50))

	rounded_arrow back_button:
		When game_starts:
			send_to_back
			set_color(h(Game.primary_color_hue, s: Game.primary_color_saturation, b: Game.primary_color_brightness + 50))
			set_angle(180)
			set_origin(to_x: 8, y: 8)
		When is_tapped(Self):
			broadcast_message(named: Game.üì£back_to_level_select)

	square unplay_cover:
		Game.üì£back_to_level_select = "unplay"
		When game_starts:
			# Slight delay to give loading screen some time on returning to this screen
			repeat(times: 5):
				wait(seconds: 0)
			set_position(to_x: 014, y: 100000)
			set_width(Game.width * 2, height: Game.height * 2)
		When i_get_a_message(Game.üì£back_to_level_select):
			set_color(h(Game.primary_color_hue, s: Game.primary_color_saturation, b: Game.primary_color_brightness))
			bring_to_front
			start_sound("dash", wait: 0)
			custom_block ease_position_and_size(from_x: Game.width / 2, to_x: Game.width / 2, from_y: Game.height + Self.height, to_y: Game.height + 8 - Self.height / 2, from_size: Self.size_as_a_percent, to_size: Self.size_as_a_percent, milliseconds: 500)
			change_scene(to: Scenes.scene_1)
Scene scene_1:

custom_block wait_for_level_with(index: 0):
	custom_block get_length_of(list: Game.generated_levels)
	check_once_if(Self.‚Ü©Ô∏èüìälist_length + Game.generated_levels_list_offset <= index):
		wait(seconds: 0)
		custom_block wait_for_level_with(index: index)