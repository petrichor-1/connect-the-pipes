Import "secretblocks.htn"
Import "./winScreen.htn"
Import "./loadingScreen.htn"
Import "./levelGeneratorBlocks.htn"
Import "./displayTiles.htn"
Import "./lists.htn"

Scene game:
	text level_generator(text: ""):
		When game_starts:
			check_if_else(Self.clone_index == 0):
				Game.generated_levels = 0
				Game.generated_levels_list_offset = 0
				create_a_clone_of_this_object
			else:
				destroy
		When object_is_cloned:
			set_background(color: h(Game.primary_color_hue, s: Game.primary_color_saturation, b: Game.primary_color_brightness))
			custom_block create_list(length_length: 2, content_index_length: 4)
			Game.generated_levels = Self.↩️📊created_list
			Game.generated_levels_list_offset = Game.current_level_index
			index_of_level_generation = Game.current_level_index
			repeat_forever:
				check_if_else(length(Game.generated_levels) < 2500):
					custom_block generate_level(width: Game.board_width, height: Game.board_height, seed: index_of_level_generation)
					custom_block append_to(list: Game.generated_levels, new_item: Self.↩️generated_board)
					Game.generated_levels = Self.↩️📊appended_list
					increase(index_of_level_generation, by: 1)
					# show_popup(message: Game.generated_levels)
				else:
					check_once_if(Game.current_level_index > Game.generated_levels_list_offset):
						list = Game.generated_levels
						new_offset = Game.generated_levels_list_offset
						repeat(times: Game.current_level_index - Game.generated_levels_list_offset):
							custom_block remove_item_in(list: list, at_index: 0)
							# show_popup(message: join("Before: ", with: join(list, with: join("
							# 
							# after: ", with: Self.↩️📊removed_list))))
							list = Self.↩️📊removed_list
							increase(new_offset, by: 1)
						custom_block rebuild(list: list)
						Game.generated_levels = Self.↩️📊rebuilt_list
						Game.generated_levels_list_offset = new_offset

	text tiles(text: ""):
		📣check_board = "Check board for finished"
		Game.📣play = "play"
		Game.📣Success = "Success!"
		When game_starts:
			broadcast_message(named: Game.📣play)
		When i_get_a_message(Game.📣play):
			check_if_else(Self.clone_index == 0):
				Game.is_loading = "true"
				# show_popup(message: join("Looking for level with index ", with: Game.current_level_index))
				custom_block wait_for_level_with(index: Game.current_level_index)
				custom_block get_item_in(list: Game.generated_levels, at_index: Game.current_level_index - Game.generated_levels_list_offset)
				Self.board = Self.↩️📊list_item
				# Self.board = "|||R||RL||UL||RU||UL|||R|RULRUDL|RDL|UDL|||R|RDL|RDL||RL|UDL|||U|||R||RL||UL||UD||RD||RL||RL|RDL||DL:"
				create_clones_of_this_object(times: Game.board_width * Game.board_height)
				Game.is_loading = "false"
				Game.total_taps = 0
				# show_popup(message: Self.board)
			else:
				Original_object.clone_index_offset = Self.clone_index
				destroy
		When object_is_cloned:
			clone_index = Self.clone_index - Original_object.clone_index_offset - 1
			x = clone_index % Game.board_width
			Self.x = x
			y = floor(clone_index / Game.board_width)
			Self.y = y
			Self.tile_size = min(Game.height * 0.6 / Game.board_height, Game.width * 0.6 / Game.board_width)
			origin_position_x = Game.width / 2 - Self.tile_size * Game.board_width / 2 + Self.tile_size / 2
			origin_position_y = Game.height / 2 - Self.tile_size * Game.board_height / 2 + Self.tile_size / 2
			custom_block get_tile_at(x: x, y: y, board: Self.board, width: Game.board_width)
			custom_block set_image_for(tile: Self.↩️tile)
			# set_text(to: Self.↩️tile, color: h(0,s:0,b:0))
			Self.center_x_position = origin_position_x + Self.tile_size * x
			Self.center_y_position = origin_position_y + Self.tile_size * y
			wait(seconds: 0)
			aspect_ratio = Self.height / Self.width
			set_width(Self.tile_size * Self.📺width_multiplier, height: aspect_ratio * Self.tile_size * Self.📺height_multiplier)
			Self.times_tapped = random(0, to: 3)
			set_color(h(Game.primary_color_hue, s: Game.primary_color_saturation + 60, b: Game.primary_color_brightness + 50))
			repeat_forever:
				set_position(to_x: Self.center_x_position + Self.tile_size * Self.📺offset_radius * cos(Self.📺offset_angle + Self.times_tapped * 90), y: Self.center_y_position + Self.tile_size * Self.📺offset_radius * sin(Self.📺offset_angle + Self.times_tapped * 90))
				set_angle(Self.📺rotation_offset + Self.times_tapped * 90)
		When is_tapped(Screen):
			check_once_if(absolute_value(Game.last_touch_x - Self.center_x_position) < Self.tile_size / 2 and absolute_value(Game.last_touch_y - Self.center_y_position) < Self.tile_size / 2):
				increase(Self.times_tapped, by: 1)
				increase(Game.total_taps, by: 1)
				broadcast_message(named: 📣check_board)
				wait(seconds: 0)
				check_once_if(Game.board_complete == "true"):
					broadcast_message(named: Game.📣Success)
		When i_get_a_message(📣check_board):
			check_if_else(Self.clone_index == 0):
				Game.board_complete = "true"
			else:
				check_once_if(Self.times_tapped % Self.symmetry != 0):
					Game.board_complete = "false"

	text tap_count_display(text: "Taps: 0"):
		When game_starts:
			send_to_back
			set_position(to_x: Game.width / 2, y: Game.height - Self.height / 2 - 8)
			repeat_forever:
				set_text(to: join("Taps: ", with: Game.total_taps), color: h(Game.primary_color_hue, s: Game.primary_color_saturation + 60, b: Game.primary_color_brightness + 50))

custom_block wait_for_level_with(index: 0):
	custom_block get_length_of(list: Game.generated_levels)
	check_once_if(Self.↩️📊list_length + Game.generated_levels_list_offset <= index):
		wait(seconds: 0)
		custom_block wait_for_level_with(index: index)